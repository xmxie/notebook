# 面试问题整理

## 内存管理的缓存池机制

优点：可以避免对象的大量创建

## 编译流程

预处理、编译、汇编、链接

## C++崩溃原因

https://www.cnblogs.com/zhoug2020/p/6025388.html

常见错误类型：

- 访问错误（越界、空指针、无效对象、迭代器）
- 内存泄漏
- 参数错误
- 堆栈溢出
- 内存碎片

## **内存分配算法**



## Tarjan 算法

https://zhuanlan.zhihu.com/p/101923309

关键词：时间戳、深度搜索、dfn[u] < low[v]

简单描述：从任意一个点出发，记录当前点被访问的顺序，之后记录从当前点不经过父节点能到达的路径的最短序号，如果该序号大于父节点序号，则此路径为桥（关键路径）

## 重载（overloaded）/重写(overwrite)/覆盖(override)

**overloaded**

如果同一作用域内的几个函数名字相同但形参列表不同，我们称之为重载函数

**override**

派生类需要对虚函数提供自己的新定义以覆盖从基类继承而来的旧定义

# C++三大特性（面向对象的三个特性）

继承，多态，封装

# 关键字 

## const

### 初始化

初始化后不能修改的变量（只能进行一次初始化），必须初始化

可以进行类型检测

可以赋值给非const对象，

但是const指针不可以用于非const指针初始化

**对象中声明的const变量必须在构造函数的初始化列表中初始化**

- 构造函数不能被声明为const函数
- 性能优化，当初始化列表中有类对象时，减少类对象的默认构造函数调用

### 作用域及引用/指针的问题

默认情况下仅在文件内有效

可以使用extern将const变量应用于其他文件

修改const引用的原变量（非const)，可以对值进行修改

初始化常量引用时允许用任意表达式

### 常量指针和指针常量

**常量指针（指向常量的指针）和指针常量（地址是常量，指针指向的地址不变）**

1. `int const* cur`;  常量指针，指向常量的指针

2. `const int * cur;`  常量指针，指向常量的指针

3. `int*const cur;`  指针常量

4. `const(int *) cur;`  //错误，不可以这么写

### 函数中的const

1. 修饰参数

   对形参使用const可以限定函数内不可以修改该参数，传入的实参不一定为const对象

2. 修饰返回值

   返回值的内容不允许被改动，接收返回值的对象必须为const对象不常用。只对指针/自定义对象有效

3. 修饰成员函数

   其不会修改数据成员。使用如下

   `void fun() const`

4. 调用问题

   a. const对象只能访问const成员函数,而非const对象可以访问任意的成员函数,包括const成员函数.

   b. const对象的成员是不可修改的,然而const对象通过指针维护的对象却是可以修改的.

   c. const成员函数不可以修改对象的数据,不管对象是否具有const性质.它在编译时,以是否修改成员数据为依据,进行检查.

   e. 然而加上mutable修饰符的数据成员,对于任何情况下通过任何手段都可修改,自然此时的const成员函数是可以修改它的。

## static

### 静态成员变量

1. 静态成员变量是该类中的所有对象所共有的，在内存中只有一份

2. 存储在全局数据区，在初始化时分配内存，**且只能在类体外进行**。不赋值会被初始化，一般为0。

3. 在编译时在静态数据去分配内存，程序结束时释放。其生命周期与程序生命周期一致。

4. 无需通过对象进行访问，可以直接通过类类型名进行访问

5. sizeof（）运算符不会计算静态成员变量

6. 优点：1、不会有全局变量名冲突 2、可以是private对象

   静态整型常量，该类型成员可以直接在类中初始化，也可以在类中声明，在类定义体外进行定义。

### 静态成员函数

1. 不具有this指针，无妨访问属于类对象的非静态成员变量和非静态成员函数
2. 出现在类体外的函数定义不能指定关键字static,必须在类体内声明
3. 非静态成员函数可以任意地访问静态成员
4. 由于没有this，速度上比全局函数会稍快
5. 可以通过对象或类型名访问

### 静态全局变量

1. 静态数据区分配内存
2. 自动初始化
3. 作用域限定在声明的文件中，即使使用extern进行声明也不能在其他文件中使用

### 静态局部变量

1. 静态内存
2. 一次且仅有一次初始化
3. 自动初始化
4. 作用域为局部作用域，生命周期与程序一致

### 静态全局函数

1. 作用域限定在声明的文件中，即使使用extern进行声明也不能在其他文件中使用
2. 其它文件中可以定义相同名字的函数，不会发生冲突

## inline

1. 节约栈空间的使用，避免频繁调用函数对占内存重复开辟所带来的消耗

2. 每个调用了内联函数的文件都出现了内联函数的定义，故最好定义在头文件中
3. **inline** 的使用是有所限制的，inline 只适合涵数体内代码简单的涵数使用，不能包含复杂的结构控制语句例如 while、switch，并且不能内联函数本身不能是直接递归函数
4. inline 是一种"**用于实现的关键字**"，关键字 **inline** 必须与函数定义体放在一起才能使函数成为内联，仅将 **inline** 放在函数声明前面不起任何作用。
5. 内联会造成代码膨胀（拷贝）

## extern

### 目的

利用关键字extern可以在一个文件中引用另一个文件中定义的变量或者函数

### 用法：

1. 同一文件内，改变声明位置，通过extern声明，就会寻找该变量在其他地方的声明和初始化

2. 可以通过extern找到在其他文件中声明的变量。

3. 可以通过extern引用另一个文件中的函数，**需要指明返回值的类型和参数**，如

   ` extern void func(int a);`

### 注意：

**使用extern关键字的变量在声明文件中应为全局变量**

extern声明的变量不可以初始化（重新赋值），需在源文件进行初始化。但是声明之后可以正常进行修改。

结合const使用可以避免extern后的变量被再次修改

## virtual

菱形继承问题，避免多继承时拥有多个父类对象（抽象类）

虚构函数，允许子类重载，多态特性

可以使用指向子类对象父类指针来调用子类对虚构函数的实现

## explicit

C++中，一个参数的构造函数(或者除了第一个参数外其余参数都有缺省值的多参构造函数)，承担了两个角色。

- 用于构建单参数的类对象
- **隐含的类型转换操作符**．

```C++
Base(const char data)
{
    std::cout <<"constructor..." <<std::endl;
    this->m_data = data;
}

int main(void)
{
    Base base1('a');        // 用于构建单参数的类对象
    Base base2 = 'b';     // 隐含的类型转换操作符

    return 0;
}
```



声明为`explicit`的构造函数不能在隐式转换中使用，只能显示调用，去构造一个类对象。

`explicit`关键字只对有一个参数的类构造函数有效, 如果类构造函数参数大于或等于两个时, 是不会产生隐式转换的, 所以`explicit`关键字也就无效了



## 其他关键字

final：禁止继承该类或覆盖该虚函数

override：必须覆盖基类的匹配的虚函数，在重写基类函数使用

**noexcept:**

使用noexcept可以保证move的时候系统使用移动语义而不是复制，并且可以让编译器更好的优化代码（当遇到noexcept的函数却抛出了异常的情况，直接调用terminate()

- 每个函数都考虑noexcept会很麻烦，所以只在明显的时候使用
- 现在编译器在好路径上异常没有影响，noexcept可能的作用是减小体积
- 推荐在构造、复制等常用操作标记noexcept，这样性能提升可能会比较大。例如vector不会使用你的类move操作，除非它被标记为noexcept（有的编译器能自动推导）
- noexcept主要是给使用者看的，对编译器影响不大

https://www.zhihu.com/question/30950837/answer/50096604

# 内存

## new和malloc的区别

0.       属性

new/delete是C++关键字，需要编译器支持。malloc/free是库函数，需要头文件支持。

1.       参数

使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算。而malloc则需要显式地指出所需内存的尺寸。

2.       返回类型

new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合类型安全性的操作符。而malloc内存分配成功则是返回void * ，需要通过强制类型转换将void*指针转换成我们需要的类型。

3.       分配失败

new内存分配失败时，会抛出bac_alloc异常。malloc分配内存失败时返回NULL。

4. 自定义类型

    new会先调用operator new函数，申请足够的内存（通常底层使用malloc实现）。然后调用类型的构造函数，初始化成员变量，最后返回自定义类型指针。delete先调用析构函数，然后调用operator delete函数释放内存（通常底层使用free实现）。

    malloc/free是库函数，只能动态的申请和释放内存，无法强制要求其做自定义类型对象构造和析构工作。

5. 重载

C++允许重载new/delete操作符，特别的，布局new的就不需要为对象分配内存，而是指定了一个地址作为内存起始区域，new在这段内存上为对象调用构造函数完成初始化工作，并返回此地址。而malloc不允许重载。

6.       内存区域

**new操作符从自由存储区（free store）上为对象动态分配内存空间**，而malloc函数从堆上动态分配内存。自由存储区是C++基于new操作符的一个抽象概念，凡是通过new操作符进行内存申请，该内存即为自由存储区。而堆是操作系统中的术语，是操作系统所维护的一块特殊内存，用于程序的内存动态分配，C语言使用malloc从堆上分配内存，使用free释放已分配的对应内存。**自由存储区不等于堆，如上所述，布局new就可以不位于堆中。**
https://blog.csdn.net/nie19940803/article/details/76358673

### delete

**如果你在你使用的 delete 中加入了方括号，delete 就假设那个指针指向的是一个数组。**否则，就假设指向一个单一的对象。

### new创建多维数组的方式

```C++
int(*a)[10] = new int[3][10]//只有一维是动态的时候可以如此创建
//或者for循环创建多维动态数组
```

## allocator

在头文件\<memory>下

- 解决分配内存时构造对象造成的资源浪费问题
- 解决无默认构造函数对象的动态分配问题

```C++
allocator<string> alloc; //可以分配string的allocator对象
auto const p=alloc.allocate(n);//分配n个未初始化的string
//使用allocator分配的对象需要使用allocator的construct方法构造
alloc.construct(q,args);//args为 allocator模板类的构造参数
alloc.destroy(q);//释放构造的string
alloc.deallocate(p,n);//释放内存，需要保证内存中的对象都已经调用destroy
```



## C++的内存分布

1.栈区(stack)

存放局部变量、函数参数、返回数据、返回地址等。系统自动分配释放 ，其操作方式类似于数据结构中的栈。

2.堆区(heap)

由程序员通过malloc()等函数分配释放，若程序员不释放，程序结束时可能由OS回收。分配方式类似于链表。

3.全局区（静态区） （static）

4.文字常量区

### 栈和堆的效率问题

栈是系统提供的数据结构，计算机会在底层对栈提供支持，分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。堆则是C/C++提供的，它的机制相对复杂，显然堆的效率比栈要低得多。

## 拷贝构造函数

拷贝构造函数通常用于：

- 通过使用另一个同类型的对象来初始化新创建的对象。
- 复制对象把它作为参数传递给函数。
- 复制对象，并从函数返回这个对象。

**声明一个私有拷贝构造函数可以防止默认拷贝函数调用的发生**

### 右值引用

​		作为一种追求执行效率的语言，C++在用临时对象或函数返回值给左值对象赋值时的深度拷贝（deep copy）一直受到诟病。考虑到临时对象的生命期仅在表达式中持续，如果把临时对象的内容直接移动（move）给被赋值的左值对象，效率改善将是显著的。这就是**移动语义**的来源。

**右值引用就是为了实现移动语义与完美转发所需要而设计出来的新的数据类型。**

```C++
X&&
```

​	右值引用主要为调用移动构造函数/完美转发时的一种判断类型，为了重载而出现的“mystery Type”，当重载了如

```C++
void foo(int && i){}//形参为右值引用类型的重载
```

​	的函数后，如果传入foo的对象为右值，则会实现移动语义，调用移动构造函数而不是拷贝构造函数，从而提升效率

​	移动构造函数的具体实现**可以是任意内容**，右值引用只不过是调用这个函数的一个信号。通常移动构造函数可以节约一次复制，std::move()实现的也是一个类型转换，将对象转为右值引用并将原对象指针置空（避免之后对象析构的时候把内容删除）

```C++
//使用std::move()做类型转换，表示需要调用的是使用右值引用类型参数重载的        移动构造函数
v.push_back(std::move(str));
```

#### 引用限定符

```C++
//末尾的&为引用限定符
Foo &operator=(const Foo&) &; //只能向可修改的左值赋值
```

引用限定符可以是&或&&，分别指出this可以指向一个左值或右值。必须同时出现在函数的声明和定义中。



# 重载

CName operator ()(parm)

重载括号()可以用于函数参数的传递

重载常用友元函数的形式实现

## 友元函数

friend Cname fun()

友元函数不是成员函数

友元函数可以访问类内的private和protected对象

# C++11

## 简单的常用特性

auto

vector等初始化

## 智能指针

智能指针的原理是，接受一个申请好的内存地址，构造一个保存在栈上的智能指针对象，当程序退出栈的作用域范围后，由于栈上的变量自动被销毁，智能指针内部保存的内存也就被释放掉了（除非将智能指针保存起来）

C++11提供了三种智能指针：std::shared_ptr, std::unique_ptr, std::weak_ptr，使用时需添加头文件\<memory\>。

注意：智能指针的默认删除器不支持数组对象，默认调用的是delete而不是delete[],可以使用unique_ptr<T[]> 指向动态数组



循环引用

在引用时使用weak_ptr

### shared_ptr

**构造方式**

```C++
//args为构造函数参数
shared_ptr<T> p = make_shared<T>(args);
//q为智能指针对象
shared_ptr<T> p(q);
//结合new使用
shared_ptr<T> sp(new T(args));
//还可以指定析构函数
shared_ptr<T> sp(args,funptr);
//其中谓词形式应如下
void funptr(T*);
```



## 可变参数



## lambda

Lambda表达式完整的声明格式如下：

```
[capture list] (params list) mutable exception-> return type { function body }
```

各项具体含义如下

1. capture list：捕获外部变量列表
2. params list：形参列表
3. mutable指示符：用来说用是否可以修改捕获的变量
4. exception：异常设定
5. return type：返回类型
6. function body：函数体

其中必须的仅有1、6

捕获变量有三种情况，按值传递、按引用传递、混合传递，具体方式与函数实参传参类似

| 捕获形式    | 说明                                                         |
| ----------- | ------------------------------------------------------------ |
| []          | 不捕获任何外部变量                                           |
| [变量名, …] | 默认以值得形式捕获指定的多个外部变量（用逗号分隔），如果引用捕获，需要显示声明（使用&说明符） |
| [this]      | 以值的形式捕获this指针                                       |
| [=]         | 以值的形式捕获所有外部变量                                   |
| [&]         | 以引用形式捕获所有外部变量                                   |
| [=, &x]     | 变量x以引用形式捕获，其余变量以传值形式捕获                  |
| [&, x]      | 变量x以值的形式捕获，其余变量以引用形式捕获                  |

### 	参数注意事项

1. 参数列表中不能有默认参数

2. 不支持可变参数

3. 所有参数必须有参数名

### 绑定参数

定义在functional头文件中

auto newCallable =bind(callable , arg_list)

其中arg_list是一个逗号分隔的参数列表

如

auto g = bind(f,a,b,\_2,c,\_1);

g(\_1,\_2)会转换为调用f(a,b,\_2,c,_1)

此时g变为一个二元谓词，可以替代lambda

**其中\_1 , \_2为定义在std::placeholders命名空间下**

**如果需要传递引用，需要使用标准库函数ref**

# 多态

## 实现原理

**动态多态**

当类中存在虚函数时，编译器会在类中自动生成一个虚函数表
虚函数表是一个存储类成员函数指针的数据结构
虚函数表由编译器自动生成和维护
virtual 修饰的成员函数会被编译器放入虚函数表中
存在虚函数时，编译器会为对象自动生成一个指向虚函数表的指针（通常称之为 vptr 指针）

**静态多态**

模板

## Class和Struct的区别

> **1.默认的继承访问权。class默认的是private,strcut默认的是public。**
> **2.默认访问权限：struct作为数据结构的实现体，它默认的数据访问控制是public的，而class作为对象的实现体，它默认的成员变量访问控制是private的。**
> **3.“class”这个关键字还用于定义模板参数，就像“typename”。但关建字“struct”不用于定义模板参数**

# 多线程

**可重入：**

可重入函数也可以这样理解，重入即表示重复进入，首先它意味着这个函数可以被中断，其次意味着它除了使用自己栈上的变量以外不依赖于任何环境（包括static），这样的函数就是purecode（[纯代码](https://baike.baidu.com/item/纯代码)）可重入，可以允许有多个该函数的副本在运行，由于它们使用的是分离的栈，所以不会互相干扰。

**线程安全**

在拥有共享数据的多条线程并行执行的程序中，线程安全的代码会通过同步机制保证各个线程都可以正常且正确的执行，不会出现数据污染等意外情况。

**Join与detch**

**join**:  Join 线程，调用该函数会阻塞当前线程，直到由 *this 所标示的线程执行完毕 join 才返回。

**detach**: Detach 线程。 将当前线程对象所代表的执行实例与该线程对象分离，使得线程的执行可以单独进行。一旦线程执行完毕，它所分配的资源将会被释放。

**joinable**: 检查线程是否可被 join。检查当前的线程对象是否表示了一个活动的执行线程，由默认构造函数创建的线程是不能被 join 的。另外，如果某个线程 已经执行完任务，但是没有被 join 的话，该线程依然会被认为是一个活动的执行线程，因此也是可以被 join 的。**每个线程创建后都必须执行join或detach**