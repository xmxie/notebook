面试复习C++

# C++三大特性（面向对象的三个特性）

继承，多态，封装

# 关键字 const/static/inline/extern

## const

### 初始化

初始化后不能修改的变量（只能进行一次初始化），必须初始化

可以进行类型检测

可以赋值给非const对象，

但是const指针不可以用于非const指针初始化

**对象中声明的const变量必须在构造函数的初始化列表中初始化**

- 构造函数不能被声明为const函数
- 性能优化，当初始化列表中有类对象时，减少类对象的默认构造函数调用

### 作用域及引用/指针的问题

默认情况下仅在文件内有效

可以使用extern将const变量应用于其他文件

修改const引用的原变量（非const)，可以对值进行修改

初始化常量引用时允许用任意表达式

### 常量指针和指针常量

**常量指针（指向常量的指针）和指针常量（地址是常量，指针指向的地址不变）**

1. `int const* cur`;  常量指针，指向常量的指针

2. `const int * cur;`  常量指针，指向常量的指针

3. `int*const cur;`  指针常量

4. `const(int *) cur;`  //错误，不可以这么写

### 函数中的const

1. 修饰参数

   对形参使用const可以限定函数内不可以修改该参数，传入的实参不一定为const对象

2. 修饰返回值

   返回值的内容不允许被改动，接收返回值的对象必须为const对象不常用

3. 修饰成员函数

   其不会修改数据成员。使用如下

   `void fun() const`

4. 调用问题

   a. const对象只能访问const成员函数,而非const对象可以访问任意的成员函数,包括const成员函数.

   b. const对象的成员是不可修改的,然而const对象通过指针维护的对象却是可以修改的.

   c. const成员函数不可以修改对象的数据,不管对象是否具有const性质.它在编译时,以是否修改成员数据为依据,进行检查.

   e. 然而加上mutable修饰符的数据成员,对于任何情况下通过任何手段都可修改,自然此时的const成员函数是可以修改它的。

## static

### 静态成员变量

1. 静态成员变量是该类中的所有对象所共有的，在内存中是有一份
2. 存储在全局数据区，在初始化时分配内存，且只能在类体外进行。不赋值会被初始化，一般为0。
3. 在编译时在静态数据去分配内存，程序结束时释放。其生命周期与程序生命周期一致。
4. 无需通过对象进行访问，可以直接通过类类型名进行访问
5. sizeof（）运算符不会计算静态成员变量
6. 优点：1、不会有全局变量名冲突 2、可以是private对象

### 静态成员函数

1. 不具有this指针，无妨访问属于类对象的非静态成员变量和非静态成员函数
2. 出现在类体外的函数定义不能指定关键字static,必须在类体内声明
3. 非静态成员函数可以任意地访问静态成员
4. 由于没有this，速度上比全局函数会稍快
5. 可以通过对象或类型名访问

### 静态全局变量

1. 静态数据区分配内存
2. 自动初始化
3. 作用域限定在声明的文件中，即使使用extern进行声明也不能在其他文件中使用

### 静态局部变量

1. 静态内存
2. 一次且仅有一次初始化
3. 自动初始化
4. 作用域为局部作用域，生命周期与程序一致

### 静态全局函数

1. 作用域限定在声明的文件中，即使使用extern进行声明也不能在其他文件中使用
2. 其它文件中可以定义相同名字的函数，不会发生冲突

## inline

1. 节约栈空间的使用，避免频繁调用函数对占内存重复开辟所带来的消耗

2. 每个调用了内联函数的文件都出现了内联函数的定义，故最好定义在头文件中
3. **inline** 的使用是有所限制的，inline 只适合涵数体内代码简单的涵数使用，不能包含复杂的结构控制语句例如 while、switch，并且不能内联函数本身不能是直接递归函数
4. inline 是一种"**用于实现的关键字**"，关键字 **inline** 必须与函数定义体放在一起才能使函数成为内联，仅将 **inline** 放在函数声明前面不起任何作用。
5. 内联会造成代码膨胀（拷贝）

## extern

### 目的

利用关键字extern可以在一个文件中引用另一个文件中定义的变量或者函数

### 用法：

1. 同一文件内，改变声明位置，通过extern声明，就会寻找该变量在其他地方的声明和初始化

2. 可以通过extern找到在其他文件中声明的变量。

3. 可以通过extern引用另一个文件中的函数，**需要知名返回值的类型和参数**，如

   ` extern void func(int a);`

### 注意：

**使用extern关键字的变量在声明文件中应为全局变量**

extern生命的变量不可以初始化（重新赋值），需在源文件进行初始化。但是声明之后可以正常进行修改。

结合const使用可以避免extern后的变量被再次修改

## Virtual

菱形继承问题，避免多继承时拥有多个父类对象（抽象类）

虚构函数，允许子类重载，多态特性

可以使用指向子类对象父类指针来调用子类对虚构函数的实现



## 其他关键字

final：禁止继承该类或覆盖该虚函数

override：必须覆盖基类的匹配的虚函数，在重写基类函数使用

# 内存

## new和malloc的区别

0.       属性

new/delete是C++关键字，需要编译器支持。malloc/free是库函数，需要头文件支持。

1.       参数

使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算。而malloc则需要显式地指出所需内存的尺寸。

2.       返回类型

new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合类型安全性的操作符。而malloc内存分配成功则是返回void * ，需要通过强制类型转换将void*指针转换成我们需要的类型。

3.       分配失败

new内存分配失败时，会抛出bac_alloc异常。malloc分配内存失败时返回NULL。

4. 自定义类型

    new会先调用operator new函数，申请足够的内存（通常底层使用malloc实现）。然后调用类型的构造函数，初始化成员变量，最后返回自定义类型指针。delete先调用析构函数，然后调用operator delete函数释放内存（通常底层使用free实现）。

    malloc/free是库函数，只能动态的申请和释放内存，无法强制要求其做自定义类型对象构造和析构工作。

5. 重载

C++允许重载new/delete操作符，特别的，布局new的就不需要为对象分配内存，而是指定了一个地址作为内存起始区域，new在这段内存上为对象调用构造函数完成初始化工作，并返回此地址。而malloc不允许重载。

6.       内存区域

new操作符从自由存储区（free store）上为对象动态分配内存空间，而malloc函数从堆上动态分配内存。自由存储区是C++基于new操作符的一个抽象概念，凡是通过new操作符进行内存申请，该内存即为自由存储区。而堆是操作系统中的术语，是操作系统所维护的一块特殊内存，用于程序的内存动态分配，C语言使用malloc从堆上分配内存，使用free释放已分配的对应内存。自由存储区不等于堆，如上所述，布局new就可以不位于堆中。
https://blog.csdn.net/nie19940803/article/details/76358673

## C++的内存分布

1.栈区(stack)

存放局部变量、函数参数、返回数据、返回地址等。系统自动分配释放 ，其操作方式类似于数据结构中的栈。

2.堆区(heap)

由程序员通过malloc()等函数分配释放，若程序员不释放，程序结束时可能由OS回收。分配方式类似于链表。

3.全局区（静态区） （static）

4.文字常量区

# 重载

CName operator ()(parm)

重载括号()可以用于函数参数的传递

重载常用友元函数的形式实现

## 友元函数

friend Cname fun()

友元函数不是成员函数

友元函数可以访问类内的private和protected对象

# C++11

## 简单的常用特性

auto

vector等初始化

## 智能指针

智能指针的原理是，接受一个申请好的内存地址，构造一个保存在栈上的智能指针对象，当程序退出栈的作用域范围后，由于栈上的变量自动被销毁，智能指针内部保存的内存也就被释放掉了（除非将智能指针保存起来）

C++11提供了三种智能指针：std::shared_ptr, std::unique_ptr, std::weak_ptr，使用时需添加头文件\<memory\>。

注意：智能指针的默认删除器不支持数组对象

## 可变参数



## lambda

Lambda表达式完整的声明格式如下：

```
[capture list] (params list) mutable exception-> return type { function body }
```

各项具体含义如下

1. capture list：捕获外部变量列表
2. params list：形参列表
3. mutable指示符：用来说用是否可以修改捕获的变量
4. exception：异常设定
5. return type：返回类型
6. function body：函数体

其中必须的仅有1、6

捕获变量有三种情况，按值传递、按引用传递、混合传递，具体方式与函数实参传参类似

| 捕获形式    | 说明                                                         |
| ----------- | ------------------------------------------------------------ |
| []          | 不捕获任何外部变量                                           |
| [变量名, …] | 默认以值得形式捕获指定的多个外部变量（用逗号分隔），如果引用捕获，需要显示声明（使用&说明符） |
| [this]      | 以值的形式捕获this指针                                       |
| [=]         | 以值的形式捕获所有外部变量                                   |
| [&]         | 以引用形式捕获所有外部变量                                   |
| [=, &x]     | 变量x以引用形式捕获，其余变量以传值形式捕获                  |
| [&, x]      | 变量x以值的形式捕获，其余变量以引用形式捕获                  |

### 参数注意事想

1. 参数列表中不能有默认参数
2. 不支持可变参数
3. 所有参数必须有参数名

# 多态

## 实现原理

当类中存在虚函数时，编译器会在类中自动生成一个虚函数表
虚函数表是一个存储类成员函数指针的数据结构
虚函数表由编译器自动生成和维护
virtual 修饰的成员函数会被编译器放入虚函数表中
存在虚函数时，编译器会为对象自动生成一个指向虚函数表的指针（通常称之为 vptr 指针）