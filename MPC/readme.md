姚氏混淆电路笔记

# 百万富翁问题

### 关键值，目的和前提

| 值    | 意义                                   |
| ----- | -------------------------------------- |
| $a,b$ | Alice和Bob的财富                       |
| $x$   | 一个随机大数                           |
| $k$   | 加密方公钥                             |
| $e$   | $x$使用公钥加密后的结果                |
| $p$   | 一个素数                               |
| $n$   | 一个阈值                               |
| $d$   | $d$是由加密方对 $r$ 进行解密得到的结果 |
| $r$   | $r$是由加密方对$d$处理后的结果         |

目的：两个人比较财富，希望知道谁更富有。但是不能让对方知道自己的财富。

前提：半诚实模型，即双方互相怀疑，但是都会遵守协议规则

### 流程

假定Alice为加密方，Bob为随机数选取方（都是我随便取的名称，便于识别身份，具体看下方流程）

1. Bob选择一个随机大数 $x$ ，**该数对Alice保密**
2. Bob使用**Alice**的公钥对$x$进行加密，获得一个加密后的结果$e$. 这里得到的**加密结果只有Alice可以进行解密**
3. Bob将加密后的结果减去自己的财富$b$，将得到的结果 $r=e-b$发送给Alice
4. Alice拿到 Bob发送到结果后，对$e-b+1,e-b+2,...,e-b+n$进行计算，得到$d_1,d_2,...,d_n$，这里的$d_b=x$
5. Alice解谜得到$r$,$r_i=\left\{\begin{aligned}& D(d_i) &(i\leq a) \\ &D(d_i+1) &(i>a) \end{aligned} \right.$，而后再进行$r=mod(r,p)$的操作后，将其发送给Bob
6. Bob只需看$r_b$,如果$r_b$得到的结果为$x$，则意味着Alice的财富大于等于Bob的财富，否则Alice的财富小于Bob的财富

*质数取余是为了避免泄露Alice的数据


# Garbled Circuit

仅考虑两方合作的情况，同样为半诚信模型

与百万富翁问题类似，双方在信息交换的过程中，关键是两者都始终拥有对方所无法掌握的信息，但最终又能得到所有结果。

首先所有的算法都可以转换或者说还原为电路执行方法，即如计算机底层通过与或非门处理二进制数据的方法。假设我们已经得到了所需执行文件的电路文件

![img](https://pic2.zhimg.com/80/v2-9304af3c65759fa13885147c659c6749_720w.jpg)

姚氏加密混淆电路首先需要电路生成方即加密方（类比百万富翁问题)，假设为Alice，需要对电路的每一个门可能的输入及输出进行加密。加密过程如下：

![img](https://pic3.zhimg.com/80/v2-4f6e168381775765f530bd14ebef987e_720w.jpg)



1. 对每个门每个输入可能的值选取一个随机大数进行替代，如图所示的AND门，则会产生一共六个随机大数对应所有可能的结果。

2. 通过指定的加密方法（加密方法公开，如AES），对所有输入情况的真值表进行加密，如对图示的AND门，得到如下的真值表，即用**输入值作为key对输出的真值进行加密**。当门串联起来后，或许需要多次加密。加密的计算量可能很大，这也是混淆电路效率较低的重要原因。

   ![img](https://pic2.zhimg.com/80/v2-6651b7b9d6fc1bf74daaf6cea5cc8cb5_720w.jpg)

   假设第$(0,n)$的输入电路为Alice输入，第$(n,m]$的输入电路为Bob的输入，第$(m,p)$的电路为输出电路。则加密输出的结果为

   $k_{00},k_{01},k_{10},k_{11},...,k_{m0},k_{m1}$和$k_{0(m+1)},k_{1(m+1)},...,k_{0p},k_{1p}$等值对应共计2p个随机数值的**输入对照表T0**，所有门电路输入。

   $e_{m+1},e_{m+2},...e_p,$等$p-m$个加密结果值的**加密结果对照表T1**。

获得了以上结果后，执行计算的双方进行通信，过程如下：

1. 加密方Alice将自己**输入值对应的随机值**$k_{0x},k_{1x},...,k_{(n-1)x}$($x$为0|1)共n个值，以及**Bob所需要的输入对照表**$k_{n0},k{n1},...k_{m0},k{m1}$共2（m-n)个值发送给Bob。同时将**输出结果对照表T1乱序后**发送给Bob。**混淆电路的混淆即主要体现在此前的加密与此时的乱序**。

2. Bob根据自己的真实输入与输入对照表选择$k_{ny},k_{(n+1)y},...,k_{my}$(y为0|1)。此时Bob拥有所有输入位电路输入值对应的随机大数，（但Bob**对于Alice的输入完全不了解意义**，因为其本身为无意义的随机数），于是Bob可以使用手中的输入值对输出结果对照表进行解密得到$k_{mz},k_{(m+1)z},...,k_{pz}$的输出结果对应随机值。对Bob而言，得到的随机值并没有意义。

   此步有两个重要问题：

   (1)Bob如果拿到了自己完整的输入对照表，则存在安全隐患。如上图所示的AND门电路真值表，他实际可以用于解密的值将有两个，用Alice的输入$k_{?x}$和$k_{1y},k_{0y}$的组合，Bob可以解密得到$k_{0z},k_{1z}$两个值。这是不安全的。

    	所以现在的实际应用中一般使用**OT协议**，即Bob只根据自己的输入得到相应的k值，而Alice并不会得到Bob的输入值的传输协议方法。

   (2)Bob需要知道解密得到的结果$k_{?z}$是否正确，直接解密得到的结果可能收传输时数据错误等问题影响导致结果错误。故需要有对结果进行验证的方法。

   ​     可能的解决方案之一是使用特殊的加密方法，当解密成果的时候返回一个特殊值表示解密成功或当解密失败的时候能告知解密失败。解密失败的意义为输入的密钥与存在的可能不符合。

3. Bob将得到的输出结果发送给Alice，此时**只有Alice拥有完整的输入对照表T0**,Alice根据Bob发送的结果对照得到真实的输出$z_{m+1},z{m+2},...,z_{p}$,而后将结果共享给Bob。



分析：

在通信过程中，Alice始终是唯一拥有完整的输入对照表的人，此时Alice更类似于百万富翁问题中唯一知道随机数$x$的Bob，只有他可以对计算得到的结果赋予意义。

而Bob则是拥有双方完整的输入真值对照的随机值，Alice只拥有自己的输入真值对照的随机值。Bob通过解密计算掩盖了自己的真值，而后将解密的结果共享使得计算能够继续。

对于图示的例子，似乎Alice可以根据结果来反推Bob的输入，使得Bob的隐私被泄露了。但是在真实情况下，电路显然不可能是只有一个门的。当电路复杂起来之后，要根据结果与自己的输入来推得另一个人的输入，难度将**呈指数爆炸增长，不可能遍历计算**。故可以认为Alice不能获取Bob的输入信息。其可能造成的信息泄露可以类比百万富翁问题中，通过计算结果双方总是能根据自己的财富得到对方的财富的一个范围区间。这种信息泄露应该是参与多方计算所可以接受的。所以可以认为姚氏混淆电路是隐私安全的。